/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /gh/webflow/brand_studio@4f0eb75/global-brand-code/custom-components/fluted-glass.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function initializeOptimizedShaders(){if("undefined"==typeof THREE)return;const e=/iPad|iPhone|iPod/.test(navigator.userAgent)||"MacIntel"===navigator.platform&&navigator.maxTouchPoints>1,t=/^((?!chrome|android|crios|fxios|edgios).)*safari/i.test(navigator.userAgent)||e,n=(!(!window.safari||!window.safari.pushNotification)||/constructor/i.test(window.HTMLElement),window.matchMedia("(prefers-reduced-motion: reduce)").matches);function o(e,t){if(!e)return null;if(e.startsWith("var(")){const t=e.match(/var\(\s*(--[^,\)]+)\s*(?:,\s*([^)]+))?\s*\)/);if(t){const e=t[1],n=t[2],o=getComputedStyle(document.documentElement);let r=o.getPropertyValue(e).trim();if(!r){const t=e.replace("--",""),n=[`--${t}`,`--${t.replace(/--/g,"-")}`,`--${t.toLowerCase()}`,`--${t.replace(/([A-Z])/g,"-$1").toLowerCase()}`,`--${t.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}`,`--${t.replace(/-/g,"").toLowerCase()}`,`--${t.replace(/([A-Z])/g,(e=>e.toLowerCase()))}`];for(const e of n)if(r=o.getPropertyValue(e).trim(),r)break}if(r)return r;if(n)return n.trim()}return null}return e}const r={maxInstances:8,isMobile:/Mobi/i.test(navigator.userAgent),resolutionScale:.75,renderBudget:40,targetFPS:30};let a=0;const i=new Set;let s=0,l=0,c=!1;function u(){const e=256,t=new Uint8Array(196608);for(let n=0;n<e;n++)for(let o=0;o<e;o++){const r=3*(n*e+o),a=n/e,i=o/e;t[r]=255*Math.sin(a*Math.PI),t[r+1]=255*Math.sin(i*Math.PI*2),t[r+2]=255*Math.sin((a+i)*Math.PI)}const n=new THREE.DataTexture(t,e,e,THREE.RGBFormat);return n.needsUpdate=!0,n.wrapS=THREE.ClampToEdgeWrapping,n.wrapT=THREE.ClampToEdgeWrapping,n.minFilter=THREE.LinearFilter,n.magFilter=THREE.LinearFilter,n}async function d(e,s){const l={},d=async f=>{try{switch(f){case 0:a++,l.isLowQuality=r.isMobile||a>2;const f=e.getAttribute("data-width-preset")||"minimal",p={balanced:{c:5,v:1,d:.2},extremes:{c:4,v:1.8,d:.15},minimal:{c:3,v:1.5,d:.1},dense:{c:7,v:.8,d:.25}},g=p[f]||p.balanced;let m=null;const b=e.querySelector(".fluted-glass-image");m=!b||"IMG"!==b.tagName||!b.src||b.src.includes("placeholder")||b.src.includes("default")||b.src.includes(".svg")?e.getAttribute("data-background-image")||null:b.src,l.settings={columns:parseInt(e.getAttribute("data-columns"))||g.c,noise:parseFloat(e.getAttribute("data-noise"))||(l.isLowQuality?.015:.035),distortion:parseFloat(e.getAttribute("data-distortion"))||1.5*g.d,widthVariation:parseFloat(e.getAttribute("data-width-variation"))||g.v,sensitivityOne:parseFloat(e.getAttribute("data-sensitivity-one"))||.08,sensitivityTwo:parseFloat(e.getAttribute("data-sensitivity-two"))||.05,sensitivityThree:parseFloat(e.getAttribute("data-sensitivity-three"))||.1,hoverIntensity:parseFloat(e.getAttribute("data-hover-intensity"))||1,hoverEnabled:!n&&"false"!==e.getAttribute("data-hover"),backgroundImage:m,backgroundColor:e.getAttribute("data-bg-color")||null};const h=function(e,t,n){const o=[0];let r=0;const a=[];for(let o=0;o<e;o++){const e=(n=(1664525*n+1013904223)%4294967296)/4294967296;a.push(Math.max(.1,1+(e-.5)*t)),r+=a[o]}let i=0;for(let e=0;e<a.length-1;e++)i+=a[e]/r,o.push(i);return o.push(1),o}(l.settings.columns,l.settings.widthVariation,parseInt(e.getAttribute("data-seed"))||1234);l.lookupTexture=function(e,t=512){const n=new Uint8Array(4*t);let o=0;for(let r=0;r<t;r++){const a=r/(t-1);for(;o<e.length-2&&a>=e[o+1];)o++;n[4*r]=o,n[4*r+3]=255}const r=new THREE.DataTexture(n,t,1,THREE.RGBAFormat);return r.needsUpdate=!0,r}(h),l.backgroundTextureData=await async function(e){return new Promise((t=>{if(!e)return void t({texture:null,aspect:1});const n=new Image;n.crossOrigin="anonymous",n.onload=function(){const n=this.width/this.height,o=new THREE.TextureLoader;o.setCrossOrigin("anonymous"),o.load(e,(e=>{e.wrapS=THREE.ClampToEdgeWrapping,e.wrapT=THREE.ClampToEdgeWrapping,e.minFilter=THREE.LinearFilter,e.magFilter=THREE.LinearFilter,t({texture:e,aspect:n})}),void 0,(()=>t({texture:u(),aspect:1})))},n.onerror=()=>t({texture:u(),aspect:1}),n.src=e}))}(l.settings.backgroundImage),l.blurredBackgroundData=await async function(e){return new Promise((n=>{if(!e||!e.texture)return void n({texture:null,aspect:1});const o=e.texture,r=e.aspect;if(t)n({texture:o,aspect:r});else try{const e=document.createElement("canvas"),t=e.getContext("2d");e.width=512,e.height=512;const a=new Image;a.crossOrigin="anonymous",a.onload=function(){t.filter="blur(15px)",t.drawImage(a,0,0,e.width,e.height),(new THREE.TextureLoader).load(e.toDataURL(),(e=>{e.wrapS=THREE.ClampToEdgeWrapping,e.wrapT=THREE.ClampToEdgeWrapping,e.minFilter=THREE.LinearFilter,e.magFilter=THREE.LinearFilter,n({texture:e,aspect:r})}))},a.onerror=()=>{n({texture:o,aspect:r})},o.image&&o.image.src?a.src=o.image.src:n({texture:o,aspect:r})}catch(e){n({texture:o,aspect:r})}}))}(l.backgroundTextureData),setTimeout((()=>d(1)),20);break;case 1:l.scene=new THREE.Scene,l.camera=new THREE.OrthographicCamera(-.5,.5,.5,-.5,-1,1),l.renderer=new THREE.WebGLRenderer({alpha:!0,antialias:!1,powerPreference:"high-performance",precision:"lowp",stencil:!1,depth:!1,premultipliedAlpha:!1}),l.renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));const{clientWidth:v,clientHeight:_}=e;l.renderer.setSize(Math.floor(v*r.resolutionScale),Math.floor(_*r.resolutionScale)),l.renderer.domElement.style.width="100%",l.renderer.domElement.style.height="100%",e.appendChild(l.renderer.domElement),setTimeout((()=>d(2)),20);break;case 2:l.uniforms={u_time:{value:0},u_resolution:{value:new THREE.Vector2(e.clientWidth,e.clientHeight)},u_aspect:{value:e.clientWidth/e.clientHeight},u_blob1_pos:{value:new THREE.Vector2(.15,.7)},u_blob2_pos:{value:new THREE.Vector2(.5,.2)},u_blob3_pos:{value:new THREE.Vector2(.85,.6)},u_column_lookup:{value:l.lookupTexture},u_noise:{value:l.settings.noise},u_distortion:{value:l.settings.distortion},u_color_one:{value:new THREE.Color(o(e.getAttribute("data-color-one")||"#5983f8")||"#5983f8")},u_size_one:{value:parseFloat(e.getAttribute("data-size-one"))||.7},u_color_two:{value:new THREE.Color(o(e.getAttribute("data-color-two")||"#c1ff5b")||"#c1ff5b")},u_size_two:{value:parseFloat(e.getAttribute("data-size-two"))||.6},u_use_blob_one:{value:"false"!==e.getAttribute("data-use-blob-one")},u_use_blob_two:{value:"false"!==e.getAttribute("data-use-blob-two")},u_use_three_color:{value:"true"===e.getAttribute("data-use-three-color")},u_color_three:{value:new THREE.Color(o(e.getAttribute("data-color-three")||"#ffff5b")||"#ffff5b")},u_size_three:{value:parseFloat(e.getAttribute("data-size-three"))||.65},u_shape_type_one:{value:parseInt(e.getAttribute("data-shape-type-one"))||0},u_shape_type_two:{value:parseInt(e.getAttribute("data-shape-type-two"))||0},u_shape_type_three:{value:parseInt(e.getAttribute("data-shape-type-three"))||0},u_background_texture:{value:l.blurredBackgroundData.texture},u_has_background:{value:null!==l.blurredBackgroundData.texture},u_background_aspect:{value:l.blurredBackgroundData.aspect},u_background_color:{value:l.settings.backgroundColor?new THREE.Color(o(l.settings.backgroundColor)||l.settings.backgroundColor):new THREE.Color(0,0,0)},u_has_bg_color:{value:null!==l.settings.backgroundColor&&""!==l.settings.backgroundColor},u_is_safari:{value:t}},l.material=new THREE.ShaderMaterial({uniforms:l.uniforms,transparent:!0,precision:"lowp",vertexShader:"varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }",fragmentShader:"\n                          #ifdef GL_ES\n                          precision lowp float;\n                          #endif\n\n                          uniform vec2 u_resolution;\n                          uniform float u_time;\n                          uniform float u_aspect;\n                          uniform vec2 u_blob1_pos;\n                          uniform vec2 u_blob2_pos;\n                          uniform vec2 u_blob3_pos;\n                          uniform sampler2D u_column_lookup;\n                          uniform float u_noise;\n                          uniform float u_distortion;\n                          uniform bool u_use_blob_one;\n                          uniform bool u_use_blob_two;\n                          uniform bool u_use_three_color;\n                          uniform vec3 u_color_one;\n                          uniform float u_size_one;\n                          uniform vec3 u_color_two;\n                          uniform float u_size_two;\n                          uniform vec3 u_color_three;\n                          uniform float u_size_three;\n                          uniform int u_shape_type_one;\n                          uniform int u_shape_type_two;\n                          uniform int u_shape_type_three;\n                          uniform sampler2D u_background_texture;\n                          uniform bool u_has_background;\n                          uniform float u_background_aspect;\n                          uniform vec3 u_background_color;\n                          uniform bool u_has_bg_color;\n                          uniform bool u_is_safari;\n                          varying vec2 vUv;\n\n                          float random(vec2 st) { \n                              return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5); \n                          } \n\n                          vec2 random2(vec2 st) { \n                              st = vec2(dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3))); \n                              return -1.0 + 2.0*fract(sin(st)*43758.5453123); \n                          }\n\n                          float noise(vec2 st) {\n                              vec2 i = floor(st);\n                              vec2 f = fract(st);\n                              vec2 u = f*f*(3.0-2.0*f);\n                              return mix(mix(dot(random2(i + vec2(0.0,0.0)), f - vec2(0.0,0.0)),\n                                          dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n                                      mix(dot(random2(i + vec2(0.0,1.0)), f - vec2(0.0,1.0)),\n                                          dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);\n                          }\n\n                          float noiseBlob(vec2 pos, vec2 center, float size, float time) {\n                              vec2 offset = pos - center;\n                              float dist = length(offset);\n                              \n                              float angle = atan(offset.y, offset.x);\n                              float edgeNoise = sin(angle * 4.0 + time * 0.8) * 0.06 + \n                                              sin(angle * 7.0 - time * 0.6) * 0.03 +\n                                              sin(angle * 11.0 + time * 0.4) * 0.015;\n                              \n                              float organicRadius = size * (1.0 + edgeNoise);\n                              \n                              float normalizedDist = dist / organicRadius;\n                              if (normalizedDist >= 1.0) return 0.0;\n                              \n                              float intensity = 1.0 - (normalizedDist * normalizedDist);\n                              return intensity * intensity;\n                          }\n\n                          float rectangleShape(vec2 pos, vec2 center, float size, float time) {\n                              vec2 offset = pos - center;\n                              \n                              float rotation = time * -0.005; \n                              float cosR = cos(rotation);\n                              float sinR = sin(rotation);\n                              vec2 rotatedOffset = vec2(\n                                  offset.x * cosR - offset.y * sinR,\n                                  offset.x * sinR + offset.y * cosR\n                              );\n                              \n                              float animScale = 1.0 + sin(time * 0.5) * 0.005;\n                              vec2 rectSize = vec2(size * animScale * 0.7, size * animScale * 0.5);\n                              \n                              vec2 absOffset = abs(rotatedOffset);\n                              vec2 edgeDistance = max(absOffset - rectSize, 0.0);\n                              float dist = length(edgeDistance) + max(max(absOffset.x - rectSize.x, absOffset.y - rectSize.y), 0.0);\n                              \n                              float gradientWidth = size * 0.6;\n                              float coreSize = size * 0.3;\n                              \n                              float intensity;\n                              if (dist < coreSize) {\n                                  intensity = 1.0;\n                              } else {\n                                  intensity = 1.0 - smoothstep(coreSize, coreSize + gradientWidth, dist);\n                              }\n                              \n                              return max(0.0, intensity);\n                          }\n\n                          float starShape(vec2 pos, vec2 center, float size, float time) {\n                              vec2 offset = pos - center;\n                              \n                              float rotation = time * 0.08;\n                              float cosR = cos(rotation);\n                              float sinR = sin(rotation);\n                              vec2 q = vec2(\n                                  offset.x * cosR - offset.y * sinR,\n                                  offset.x * sinR + offset.y * cosR\n                              );\n                              \n                              const float segments = 5.0;\n                              const float indent = 0.05;\n                              const float pi = 3.141592654;\n                              \n                              float angle = (atan(q.y, q.x) + pi) / (2.0 * pi);\n                              float segment = angle * segments;\n                              \n                              float segmentI = floor(segment);\n                              float segmentF = fract(segment);\n                              \n                              angle = (segmentI + 0.5) / segments;\n                              \n                              if (segmentF > 0.5) {\n                                  angle -= indent;\n                              } else {\n                                  angle += indent;\n                              }\n                              \n                              angle *= 2.0 * pi;\n                              \n                              vec2 outline = vec2(cos(angle), sin(angle));\n                              float distance = abs(dot(outline, q)) / size;\n                              \n                              float cornerRadius = 0.35;\n                              distance = distance - cornerRadius * (1.0 - distance);\n                              \n                              float gradientWidth = 0.6;\n                              float coreSize = 0.05;\n                              \n                              float intensity;\n                              if (distance < coreSize) {\n                                  intensity = 1.0;\n                              } else {\n                                  intensity = 1.0 - smoothstep(coreSize, coreSize + gradientWidth, distance);\n                              }\n                              \n                              return max(0.0, intensity);\n                          }\n\n                          float triangleShape(vec2 pos, vec2 center, float size, float time) {\n                              vec2 offset = pos - center;\n                              \n                              float rotation = time * 0.03;\n                              float cosR = cos(rotation);\n                              float sinR = sin(rotation);\n                              vec2 rotatedOffset = vec2(\n                                  offset.x * cosR - offset.y * sinR,\n                                  offset.x * sinR + offset.y * cosR\n                              );\n                              \n                              float triangleSize = size;\n                              vec2 p = rotatedOffset / triangleSize;\n                              \n                              const float k = sqrt(3.0);\n                              p.x = abs(p.x) - 1.0;\n                              p.y = p.y + 1.0/k;\n                              if (p.x + k*p.y > 0.0) p = vec2(p.x - k*p.y, -k*p.x - p.y) / 2.0;\n                              p.x -= clamp(p.x, -2.0, 0.0);\n                              \n                              float triangleDist = -length(p) * sign(p.y) * triangleSize;\n                              \n                              float gradientWidth = size * 0.35;\n                              float intensity = 1.0 - smoothstep(-gradientWidth * 0.2, gradientWidth, triangleDist);\n                              \n                              return max(0.0, intensity * intensity);\n                          }\n\n                          float getShapeIntensity(vec2 pos, vec2 center, float size, float time, int shapeType) {\n                              if (shapeType == 1) {\n                                  return rectangleShape(pos, center, size, time);\n                              } else if (shapeType == 2) {\n                                  return starShape(pos, center, size, time);\n                              } else if (shapeType == 3) {\n                                  return triangleShape(pos, center, size, time);\n                              } else {\n                                  return noiseBlob(pos, center, size, time);\n                              }\n                          }           \n\n                          void main() { \n                              vec4 d = texture2D(u_column_lookup, vec2(vUv.x, 0.0)); \n                              float i = d.r * 255.0; \n                              float s = sin(i * 12.99) * 43758.5; \n                              float o = (fract(s) - 0.5) * u_distortion; \n                              vec2 distortedUV = vec2(vUv.x + o, vUv.y); \n                              \n                              vec3 backgroundColor = vec3(0.0);\n                              bool hasAnyBackground = u_has_background || u_has_bg_color;\n                              \n                              if (u_has_background) {\n                                  // Calculate cover-fit UV coordinates\n                                  vec2 backgroundUV = vUv;\n                                  backgroundUV.x += o * 0.1;\n                                  \n                                  float containerAspect = u_aspect;\n                                  float imageAspect = u_background_aspect;\n                                  \n                                  vec2 scale = vec2(1.0);\n                                  vec2 offset = vec2(0.0);\n                                  \n                                  if (containerAspect > imageAspect) {\n                                      // Container is wider than image - scale by width\n                                      scale.y = containerAspect / imageAspect;\n                                      offset.y = (1.0 - scale.y) * 0.5;\n                                  } else {\n                                      // Container is taller than image - scale by height  \n                                      scale.x = imageAspect / containerAspect;\n                                      offset.x = (1.0 - scale.x) * 0.5;\n                                  }\n                                  \n                                  vec2 coverUV = (backgroundUV - offset) / scale;\n                                  vec2 clampedBackgroundUV = clamp(coverUV, vec2(0.0), vec2(1.0));\n                                  \n                                  if (u_is_safari) {\n                                      vec3 blurResult = vec3(0.0);\n                                      float blurTotal = 0.0;\n                                      vec2 texelSize = vec2(1.0 / 512.0);\n                                      \n                                      for(float x = -6.0; x <= 6.0; x += 1.0) {\n                                          for(float y = -6.0; y <= 6.0; y += 1.0) {\n                                              vec2 offset = vec2(x, y) * texelSize * 3.0;\n                                              vec2 sampleUV = clampedBackgroundUV + offset;\n                                              if(sampleUV.x >= 0.0 && sampleUV.x <= 1.0 && sampleUV.y >= 0.0 && sampleUV.y <= 1.0) {\n                                                  blurResult += texture2D(u_background_texture, sampleUV).rgb;\n                                                  blurTotal += 1.0;\n                                              }\n                                          }\n                                      }\n                                      backgroundColor = (blurResult / blurTotal) * 0.85;\n                                  } else {\n                                      backgroundColor = texture2D(u_background_texture, clampedBackgroundUV).rgb * 0.85;\n                                  }\n                              } else if (u_has_bg_color) {\n                                  backgroundColor = u_background_color;\n                              }\n\n                              vec2 aspectCorrected = vec2(distortedUV.x * u_aspect, distortedUV.y);\n                              vec2 blob1Corrected = vec2(u_blob1_pos.x * u_aspect, u_blob1_pos.y);\n                              vec2 blob2Corrected = vec2(u_blob2_pos.x * u_aspect, u_blob2_pos.y);\n                              vec2 blob3Corrected = vec2(u_blob3_pos.x * u_aspect, u_blob3_pos.y);\n                              \n                              float mobileScale = u_aspect < 1.0 ? 0.8 : 1.0;\n\n                              float intensity1 = 0.0;\n                              if(u_use_blob_one) {\n                                  intensity1 = getShapeIntensity(aspectCorrected, blob1Corrected, u_size_one * mobileScale, u_time, u_shape_type_one);\n                              }\n\n                              float intensity2 = 0.0;\n                              if(u_use_blob_two) {\n                                  intensity2 = getShapeIntensity(aspectCorrected, blob2Corrected, u_size_two * mobileScale, u_time + 100.0, u_shape_type_two);\n                              }\n\n                              float intensity3 = 0.0;\n                              if(u_use_three_color) {\n                                  intensity3 = getShapeIntensity(aspectCorrected, blob3Corrected, u_size_three * mobileScale, u_time + 200.0, u_shape_type_three);\n                              }\n                              \n                              float maxIntensity = max(max(intensity1, intensity2), intensity3);\n                              \n                              if (maxIntensity <= 0.0) {\n                                  if (hasAnyBackground) {\n                                      vec3 c = backgroundColor; \n                                      float g = (random(vUv * 0.5) - 0.5) * u_noise * 0.08; \n                                      c += g;\n                                      gl_FragColor = vec4(c, 1.0);\n                                  } else {\n                                      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n                                  }\n                                  return;\n                              }\n                              \n                              vec3 blendedColor = vec3(0.0);\n                              float totalAlpha = 0.0;\n                              \n                              vec3 currentColor = vec3(0.0);\n                              float currentAlpha = 0.0;\n                              \n                              if (intensity1 > 0.0) {\n                                  currentColor = u_color_one;\n                                  currentAlpha = intensity1;\n                              }\n                              \n                              if (intensity2 > 0.0) {\n                                  float srcAlpha = intensity2;\n                                  float dstAlpha = currentAlpha;\n                                  float outAlpha = srcAlpha + dstAlpha * (1.0 - srcAlpha);\n                                  \n                                  if (outAlpha > 0.0) {\n                                      currentColor = (u_color_two * srcAlpha + currentColor * dstAlpha * (1.0 - srcAlpha)) / outAlpha;\n                                      currentAlpha = outAlpha;\n                                  }\n                              }\n                              \n                              if (intensity3 > 0.0) {\n                                  float srcAlpha = intensity3;\n                                  float dstAlpha = currentAlpha;\n                                  float outAlpha = srcAlpha + dstAlpha * (1.0 - srcAlpha);\n                                  \n                                  if (outAlpha > 0.0) {\n                                      currentColor = (u_color_three * srcAlpha + currentColor * dstAlpha * (1.0 - srcAlpha)) / outAlpha;\n                                      currentAlpha = outAlpha;\n                                  }\n                              }\n                              \n                              blendedColor = currentColor;\n                              maxIntensity = currentAlpha;\n                              \n                              vec3 finalColor;\n                              if (hasAnyBackground) {\n                                  finalColor = mix(backgroundColor, blendedColor, maxIntensity);\n                              } else {\n                                  finalColor = blendedColor;\n                              }\n                              \n                              vec3 c = finalColor; \n                              float g = (random(vUv * 0.5) - 0.5) * u_noise * 0.12; \n                              c += g; \n                              \n                              float alpha = hasAnyBackground ? 1.0 : maxIntensity;\n                              gl_FragColor = vec4(c, alpha);\n                          }"}),l.plane=new THREE.Mesh(new THREE.PlaneGeometry(1,1),l.material),l.scene.add(l.plane),setTimeout((()=>d(3)),20);break;case 3:let y;const E={isVisible:!1,lastRenderTime:0,isHovering:!1,timeOffset:Math.random()*Math.PI*2,fadeProgress:0},w={b1:new THREE.Vector2(.15,.7),b2:new THREE.Vector2(.5,.2),b3:new THREE.Vector2(.85,.6)},x=new THREE.Vector2(.5,.5),T={b1:new THREE.Vector2(.25,.6),b2:new THREE.Vector2(.45,.3),b3:new THREE.Vector2(.75,.7)},R=(new THREE.Vector2(.15,.7),new THREE.Vector2(.5,.2),new THREE.Vector2(.85,.6),{update:e=>{if(c)return;if(e-E.lastRenderTime<33)return;E.fadeProgress<1&&E.isVisible&&(E.fadeProgress=Math.min(1,E.fadeProgress+.05),l.renderer.domElement.style.opacity=E.fadeProgress);const t=8e-4*(e+E.timeOffset);if(n)T.b1.set(.25,.6),T.b2.set(.45,.3),T.b3.set(.75,.7);else{const e=.4*t,n=.6*t,o=.8*t;T.b1.x=.25+.05*Math.sin(.7*e)+.03*Math.cos(.3*o),T.b1.y=.6+.04*Math.cos(.9*e)+.02*Math.sin(.5*n),T.b2.x=.45+.06*Math.cos(.8*n)+.0025*Math.sin(.4*e),T.b2.y=.3+.045*Math.sin(.6*n)+.02*Math.cos(.7*o),T.b3.x=.75+.055*Math.sin(.5*o)+.03*Math.cos(.8*e),T.b3.y=.7+.04*Math.cos(.4*o)+.025*Math.sin(.6*e)}if(l.settings.hoverEnabled&&E.isHovering){const e=2*(x.x-.5),t=2*(x.y-.5),n=e*l.settings.sensitivityOne*l.settings.hoverIntensity,o=t*l.settings.sensitivityOne*l.settings.hoverIntensity,r=e*-l.settings.sensitivityTwo*l.settings.hoverIntensity,a=t*-l.settings.sensitivityTwo*l.settings.hoverIntensity,i=e*l.settings.sensitivityThree*l.settings.hoverIntensity,s=t*l.settings.sensitivityThree*l.settings.hoverIntensity,c=new THREE.Vector2(T.b1.x+n,T.b1.y+o),u=new THREE.Vector2(T.b2.x+r,T.b2.y+a),d=new THREE.Vector2(T.b3.x+i,T.b3.y+s);w.b1.lerp(c,.04),w.b2.lerp(u,.03),w.b3.lerp(d,.02)}else w.b1.lerp(T.b1,.025),w.b2.lerp(T.b2,.022),w.b3.lerp(T.b3,.018);l.uniforms.u_blob1_pos.value.copy(w.b1),l.uniforms.u_blob2_pos.value.copy(w.b2),l.uniforms.u_blob3_pos.value.copy(w.b3),l.uniforms.u_time.value=t,l.renderer.render(l.scene,l.camera),E.lastRenderTime=e},setVisible:e=>{e&&!E.isVisible?(i.add(R),E.fadeProgress=0,l.renderer.domElement.style.opacity="0"):!e&&E.isVisible&&i.delete(R),E.isVisible=e}}),A=t=>{const n=e.getBoundingClientRect();x.x=(t.clientX-n.left)/n.width,x.y=1-(t.clientY-n.top)/n.height};l.settings.hoverEnabled&&(document.addEventListener("mousemove",(e=>{E.isHovering&&A(e)})),e.addEventListener("mouseenter",(()=>{E.isHovering=!0})),e.addEventListener("mouseleave",(()=>{E.isHovering=!1,x.set(.5,.5)})),setTimeout((()=>{const t=e.getBoundingClientRect(),n=e=>{e.clientX>=t.left&&e.clientX<=t.right&&e.clientY>=t.top&&e.clientY<=t.bottom&&(E.isHovering=!0),document.removeEventListener("mousemove",n)};document.addEventListener("mousemove",n)}),100)),window.addEventListener("resize",(()=>{clearTimeout(y),y=setTimeout((()=>{const{clientWidth:t,clientHeight:n}=e;l.renderer.setSize(t,n),l.renderer.domElement.style.width="100%",l.renderer.domElement.style.height="100%",l.uniforms.u_resolution.value.set(t,n),l.uniforms.u_aspect.value=t/n,l.camera.updateProjectionMatrix()}),100)})),s(R)}}catch(e){s(null)}};d(0)}requestAnimationFrame((function e(t){if(requestAnimationFrame(e),t-s<33)return;l=performance.now(),c=!1;for(const e of i){if(c)break;if(e.update(t),performance.now()-l>r.renderBudget){c=!0;break}}s=t}));const f=document.querySelectorAll("[data-fluted-glass]");if(0===f.length)return;let p=[],g=!1;function m(){if(0===p.length)return void(g=!1);g=!0;const e=p.shift();d(e,(t=>{if(t){e.shaderController=t;const n=e.getBoundingClientRect(),o=n.top<window.innerHeight+200&&n.bottom>=-200;t.setVisible(o)}setTimeout(m,200)}))}const b=new IntersectionObserver((e=>{e.forEach((e=>{const t=e.target;e.isIntersecting&&!t.shaderController&&(p.includes(t)||(p.push(t),g||setTimeout(m,100))),t.shaderController&&t.shaderController.setVisible(e.isIntersecting)}))}),{rootMargin:"200px"});f.forEach((e=>b.observe(e)))}window.addEventListener("load",(()=>{const e=navigator.hardwareConcurrency<4?800:500;setTimeout(initializeOptimizedShaders,e)}));
//# sourceMappingURL=/sm/16c149208f341dc9b6b50517a95ab1938617bf9f89e5687802a753c0710005cd.map